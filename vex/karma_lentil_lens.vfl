// KarmaLentil Lens Shader
// Polynomial optics for realistic lens aberrations
// For use with Karma CPU renderer (NOT Karma XPU)
//
// Based on lentil by Zeno Pelgrims
// Adapted for Houdini Karma CVEX lens shader format

#include <voplib.h>

// Sample uniform disk
function vector2 sample_disk(float u; float v)
{
    float r = sqrt(u);
    float theta = v * 2.0 * M_PI;
    return set(r * cos(theta), r * sin(theta));
}

// Sample polygonal aperture
function vector2 sample_polygon(float u; float v; int sides; float rotation_deg)
{
    if (sides < 3) {
        return sample_disk(u, v);
    }

    vector2 disk_sample = sample_disk(u, v);

    // Rotate
    float rot_rad = radians(rotation_deg);
    float cos_r = cos(rot_rad);
    float sin_r = sin(rot_rad);

    vector2 rotated = set(
        disk_sample.x * cos_r - disk_sample.y * sin_r,
        disk_sample.x * sin_r + disk_sample.y * cos_r
    );

    // Scale to inscribed circle of polygon
    float scale = cos(M_PI / float(sides));
    return rotated / scale;
}

// Evaluate 2D polynomial for polynomial optics
// This maps from (sensor_pos, aperture_pos) to exit pupil direction
//
// Polynomial terms for degree d:
// For each sum=0 to d:
//   For i=0 to sum:
//     j = sum - i
//     term_index = sum*(sum+1)/2 + i
//     coefficient * (x^i * y^j)
//
// Input: (x, y) normalized coordinates, coefficients array, polynomial degree
// Output: result value
function float eval_polynomial_2d_single(
    float x; float y;
    float aperture_x; float aperture_y;
    float coeffs[];
    int degree)
{
    float result = 0.0;
    int idx = 0;

    // Evaluate polynomial terms
    // For degree d, we have terms where i+j <= d
    for (int sum = 0; sum <= degree; sum++) {
        for (int i = 0; i <= sum; i++) {
            int j = sum - i;

            if (idx >= len(coeffs)) {
                break;
            }

            // Build term: we need to handle 4D input (sensor_x, sensor_y, aperture_x, aperture_y)
            // For simplicity, we'll use a 2D approximation for now
            // Full implementation would need 4D polynomial with more coefficient terms

            float term = pow(x, float(i)) * pow(y, float(j));
            result += coeffs[idx] * term;

            idx++;
        }
        if (idx >= len(coeffs)) {
            break;
        }
    }

    return result;
}

// Evaluate full 2D polynomial (returns vector2)
function vector2 eval_polynomial_2d(
    float sensor_x; float sensor_y;
    float aperture_x; float aperture_y;
    float coeffs_x[]; float coeffs_y[];
    int degree)
{
    // Evaluate both x and y components
    float result_x = eval_polynomial_2d_single(sensor_x, sensor_y, aperture_x, aperture_y, coeffs_x, degree);
    float result_y = eval_polynomial_2d_single(sensor_x, sensor_y, aperture_x, aperture_y, coeffs_y, degree);

    return set(result_x, result_y);
}

// Main lens shader - CVEX signature for Karma
cvex karma_lentil_lens(
    // Camera space ray outputs
    export vector P = 0;           // Ray origin
    export vector I = {0, 0, -1};  // Ray direction
    export float importance = 1.0;  // Ray importance for sampling

    // Lens shader inputs from Karma
    float sx = 0;                   // Screen X [-1, 1]
    float sy = 0;                   // Screen Y [-1, 1]
    float randx = 0;                // Random sample X [0, 1]
    float randy = 0;                // Random sample Y [0, 1]
    float Time = 0;                 // Shutter time [0, 1]

    // Lentil parameters
    int enable_lentil = 1;
    int use_polynomial = 1;         // Use polynomial optics (vs thin lens)
    float focal_length = 50.0;      // mm
    float fstop = 2.8;
    float focus_distance = 5000.0;  // mm
    float sensor_width = 36.0;      // mm
    float chromatic_aberration = 0.0;
    int bokeh_blades = 0;
    float bokeh_rotation = 0.0;
    float bokeh_intensity = 1.0;
    int polynomial_degree = 5;

    // Polynomial coefficients (will be populated by Python when lens is selected)
    float poly_coeffs_x[] = {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, -0.02, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0};
    float poly_coeffs_y[] = {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, -0.02, 0.0, 0.0, 0.0, 0.0, 0.01, 0.0};
)
{
    // If lentil disabled, use pinhole camera
    if (!enable_lentil || fstop >= 64.0) {
        // Pinhole: ray from origin through screen point
        float aspect = 16.0 / 9.0;  // TODO: get from camera
        P = {0, 0, 0};
        I = normalize(set(sx, sy / aspect, -1.0));
        importance = 1.0;
        return;
    }

    // Convert units: mm to camera space (assume camera space = meters)
    float focal_m = focal_length / 1000.0;
    float focus_m = focus_distance / 1000.0;
    float sensor_width_m = sensor_width / 1000.0;

    // Calculate aperture radius from f-stop
    float aperture_radius = (focal_length / (2.0 * fstop)) / 1000.0;  // to meters

    // Sample aperture
    vector2 aperture_sample;
    if (bokeh_blades > 0) {
        aperture_sample = sample_polygon(randx, randy, bokeh_blades, bokeh_rotation);
    } else {
        aperture_sample = sample_disk(randx, randy);
    }
    aperture_sample *= aperture_radius;

    // Calculate sensor position from screen coordinates
    float aspect = 16.0 / 9.0;  // TODO: get actual aspect ratio
    float sensor_half_width = sensor_width_m * 0.5;
    float sensor_half_height = sensor_half_width / aspect;

    vector sensor_pos = set(
        sx * sensor_half_width,
        sy * sensor_half_height,
        0.0
    );

    // === POLYNOMIAL OPTICS PATH ===
    if (use_polynomial && len(poly_coeffs_x) > 0) {
        // Normalize sensor and aperture positions for polynomial evaluation
        // Polynomial expects normalized coordinates [-1, 1]
        float sensor_x_norm = sx;  // Already in [-1, 1] from Karma
        float sensor_y_norm = sy;

        float aperture_x_norm = aperture_sample.x / aperture_radius;
        float aperture_y_norm = aperture_sample.y / aperture_radius;

        // Evaluate polynomial to get exit pupil direction
        vector2 exit_pupil = eval_polynomial_2d(
            sensor_x_norm, sensor_y_norm,
            aperture_x_norm, aperture_y_norm,
            poly_coeffs_x, poly_coeffs_y,
            polynomial_degree
        );

        // Convert exit pupil coordinates to 3D direction
        // The polynomial gives us the exit pupil position on the lens
        // We need to create a ray from sensor through this exit point

        // Lens position (at focal length from sensor)
        vector lens_pos = set(
            exit_pupil.x * aperture_radius,
            exit_pupil.y * aperture_radius,
            focal_m
        );

        // Calculate focus point
        float t = focus_m / focal_m;
        vector focus_point = sensor_pos + (lens_pos - sensor_pos) * t;

        // Output ray: from lens position toward focus point
        P = lens_pos;
        I = normalize(focus_point - lens_pos);

        // Apply chromatic aberration (wavelength-dependent focus)
        if (chromatic_aberration > 0.0) {
            // Proper chromatic aberration: different wavelengths refract differently
            // Red light (long wavelength) focuses further from lens
            // Blue light (short wavelength) focuses closer to lens
            //
            // Standard wavelengths (approximate):
            // Red:   ~656 nm (C line)
            // Green: ~546 nm (e line, reference)
            // Blue:  ~486 nm (F line)

            // Use random sample to select wavelength channel
            float wavelength_rand = randx;
            float focal_shift = 0.0;

            // Dispersive shift based on wavelength
            // Negative shift = shorter focal length (blue)
            // Positive shift = longer focal length (red)
            if (wavelength_rand < 0.33) {
                // Blue channel - shorter focal length
                focal_shift = -chromatic_aberration * 0.015;
            }
            else if (wavelength_rand < 0.67) {
                // Green channel - reference (no shift)
                focal_shift = 0.0;
            }
            else {
                // Red channel - longer focal length
                focal_shift = chromatic_aberration * 0.015;
            }

            // Apply focal length shift
            float focal_shifted = focal_m * (1.0 + focal_shift);

            // Recalculate focus point with shifted focal length
            // This creates the characteristic color fringing at edges
            float t_chrom = focus_m / focal_shifted;
            vector focus_point_chrom = sensor_pos + (lens_pos - sensor_pos) * t_chrom;

            I = normalize(focus_point_chrom - lens_pos);
        }

    }
    // === THIN LENS PATH (fallback) ===
    else {
        // Lens position (at focal length from sensor)
        vector lens_pos = set(aperture_sample.x, aperture_sample.y, focal_m);

        // Calculate focus point using thin lens formula
        // Ray from sensor through lens
        vector sensor_to_lens = lens_pos - sensor_pos;

        // Project to focus plane
        float t = focus_m / focal_m;
        vector focus_point = sensor_pos + sensor_to_lens * t;

        // Output ray: from lens position toward focus point
        P = lens_pos;
        I = normalize(focus_point - lens_pos);

        // Apply chromatic aberration (same as polynomial path)
        if (chromatic_aberration > 0.0) {
            float wavelength_rand = randx;
            float focal_shift = 0.0;

            if (wavelength_rand < 0.33) {
                focal_shift = -chromatic_aberration * 0.015;  // Blue
            }
            else if (wavelength_rand < 0.67) {
                focal_shift = 0.0;  // Green (reference)
            }
            else {
                focal_shift = chromatic_aberration * 0.015;  // Red
            }

            float focal_shifted = focal_m * (1.0 + focal_shift);
            float t_chrom = focus_m / focal_shifted;
            vector focus_point_chrom = sensor_pos + sensor_to_lens * t_chrom;

            I = normalize(focus_point_chrom - lens_pos);
        }
    }

    // Bidirectional sampling importance for bokeh highlights
    importance = bokeh_intensity;
}
