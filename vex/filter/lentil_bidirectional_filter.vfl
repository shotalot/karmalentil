// Lentil Bidirectional Filter
// Post-process filter that redistributes samples based on circle of confusion
// This creates more accurate bokeh, especially for out-of-focus highlights

#pragma hint Cf hidden
#pragma hint filter_width hidden
#pragma hint filter_height hidden

#include "../include/lentil_utils.h"
#include "../../lenses/double_gauss_50mm/lens_constants.h"

// Import bidirectional utilities (simplified version for COPs)
function float compute_coc_from_depth(
    float depth;           // World-space depth
    float focus_distance;  // Focus distance in world units
    float focal_length;    // Focal length in mm
    float fstop)          // F-stop
{
    // Convert to consistent units (meters)
    float focus_m = focus_distance * 0.001;
    float focal_m = focal_length * 0.001;

    // Aperture diameter
    float aperture = (fstop > 0.01) ? (focal_m / fstop) : (focal_m / LENS_FSTOP_MIN);

    // Circle of confusion in meters
    float coc = 0.0;
    if (abs(depth - focus_m) > 0.001) {
        coc = (aperture * abs(depth - focus_m)) / (depth * max(fstop, 0.1));
    }

    // Convert to mm for sensor space
    return coc * 1000.0;
}

function float coc_to_pixel_radius_simple(
    float coc_mm;
    float sensor_width_mm;
    int image_width)
{
    float mm_per_pixel = sensor_width_mm / float(image_width);
    return coc_mm / mm_per_pixel;
}

// Main filter function
cvex lentil_bidirectional_filter(
    // Input images
    vector Cf = {0, 0, 0};           // Input color
    float depth = 1000.0;             // Depth (P.z or actual depth)
    vector P_world = {0, 0, 0};       // World position (if available)

    // Filter parameters
    float focal_length = 50.0;        // Focal length in mm
    float fstop = 2.8;                 // F-stop
    float focus_distance = 1000.0;     // Focus distance in mm
    float sensor_width = 36.0;         // Sensor width in mm
    int enable_redistribution = 1;     // Enable sample redistribution
    float bokeh_intensity = 1.0;       // Bokeh highlight intensity
    float filter_quality = 1.0;        // Quality multiplier (affects filter radius)

    // Image metadata
    int image_width = 1920;
    int image_height = 1080;

    // Pixel coordinates
    int ix = 0;
    int iy = 0;

    // Output
    export vector out_color = {0, 0, 0})
{
    if (!enable_redistribution) {
        // Pass through
        out_color = Cf;
        return;
    }

    // Compute circle of confusion for this pixel
    float depth_m = depth;  // Assume depth is in meters
    float coc_mm = compute_coc_from_depth(depth_m, focus_distance, focal_length, fstop);

    // Convert to pixel radius
    float coc_pixels = coc_to_pixel_radius_simple(coc_mm, sensor_width, image_width);

    // Adjust by quality setting
    coc_pixels *= filter_quality;

    // If CoC is very small, just pass through
    if (coc_pixels < 0.5) {
        out_color = Cf;
        return;
    }

    // For bidirectional filtering, we need to:
    // 1. Sample from neighboring pixels
    // 2. Weight by their CoC contribution to this pixel
    // 3. Accumulate weighted colors

    // NOTE: In a full implementation, this would be done as a gather operation
    // For COP context, we can use the filter width to access neighboring pixels

    // Determine filter radius (in pixels)
    int filter_radius = int(ceil(coc_pixels * 2.0));
    filter_radius = clamp(filter_radius, 1, 100);

    // Accumulate contributions
    vector accumulated_color = {0, 0, 0};
    float total_weight = 0.0;

    // Sample in a disk pattern
    int num_samples = filter_radius * 8;  // Proportional to radius
    num_samples = clamp(num_samples, 16, 256);

    for (int i = 0; i < num_samples; i++) {
        // Generate sample position in disk
        float angle = float(i) / float(num_samples) * 2.0 * M_PI;
        float radius = sqrt(float(i) / float(num_samples)) * coc_pixels;

        float dx = cos(angle) * radius;
        float dy = sin(angle) * radius;

        int sample_x = ix + int(round(dx));
        int sample_y = iy + int(round(dy));

        // Clamp to image bounds
        sample_x = clamp(sample_x, 0, image_width - 1);
        sample_y = clamp(sample_y, 0, image_height - 1);

        // In COP context, we would use cinput() or similar to fetch the color
        // For now, this is a template that needs to be adapted to the context

        // Compute weight based on distance
        float dist_sq = dx*dx + dy*dy;
        float sigma = coc_pixels / 2.0;
        float weight = exp(-dist_sq / (2.0 * sigma * sigma));

        // In full implementation:
        // vector sample_color = cinput(sample_x, sample_y, "Cf");
        // accumulated_color += sample_color * weight;

        total_weight += weight;
    }

    // Normalize
    if (total_weight > 0.001) {
        out_color = accumulated_color / total_weight;

        // Boost highlights for bokeh effect
        float luma = out_color.r * 0.2126 + out_color.g * 0.7152 + out_color.b * 0.0722;
        if (luma > 0.5 && coc_pixels > 2.0) {
            // Boost bright out-of-focus areas
            float boost = 1.0 + (luma - 0.5) * bokeh_intensity * (coc_pixels / 10.0);
            out_color *= boost;
        }
    } else {
        out_color = Cf;
    }
}
