/**
 * POTK - Polynomial Lens Shader Template
 *
 * Generated VEX shader for: test_double-gauss_50mm_f/2.0
 * Focal length: 50.0mm
 * Max f-stop: f/2.0
 * Polynomial degree: 5
 *
 * This shader implements polynomial optical aberrations for physically-based
 * lens rendering in Karma CPU.
 */

#include <math.h>

/**
 * Polynomial coefficient arrays
 * These are embedded at compile-time for optimal performance
 */

// Exit pupil polynomial coefficients (sensor → lens)
float g_coeffs_exit_x[] = {
            4.2543917889e-02, 1.0000000000e+00, 7.0780385538e-02, -7.7865982292e-02,
        -6.0908593851e-02, -1.0256811161e-02, -7.9035070527e-03, 1.2447158409e-02,
        -1.1757100058e-01, -5.9984525746e-02, 7.0000815486e-04, -1.1064929653e-01,
        -1.3779407424e-01, 2.7466218111e-02, -5.8895295302e-02, 4.4573350105e-02,
        -2.7941976034e-04, 1.5172347849e-01, 4.4927075528e-02, -2.5521076953e-02,
        -5.1121935071e-02
};

float g_coeffs_exit_y[] = {
            1.5198904114e-01, 5.0867040136e-02, 1.0000000000e+00, 1.4692167906e-01,
        5.2735698559e-02, 9.4988967227e-02, -3.7279857375e-03, -6.3117503437e-02,
        1.1951755284e-01, 4.0602835794e-02, -8.4609746761e-03, 9.6705987138e-04,
        -1.1429117964e-01, 5.0601587657e-03, 9.1936196974e-02, -1.1405201469e-01,
        -1.5222080912e-01, -7.3537170034e-02, 2.8327822502e-02, 1.1896074118e-01,
        -5.7487687365e-02
};

// Entrance pupil polynomial coefficients (lens → world)
float g_coeffs_entrance_x[] = {
            4.2543917889e-02, 1.0000000000e+00, 7.0780385538e-02, -7.7865982292e-02,
        -6.0908593851e-02, -1.0256811161e-02, -7.9035070527e-03, 1.2447158409e-02,
        -1.1757100058e-01, -5.9984525746e-02, 7.0000815486e-04, -1.1064929653e-01,
        -1.3779407424e-01, 2.7466218111e-02, -5.8895295302e-02, 4.4573350105e-02,
        -2.7941976034e-04, 1.5172347849e-01, 4.4927075528e-02, -2.5521076953e-02,
        -5.1121935071e-02  // Placeholder - will be computed separately
};

float g_coeffs_entrance_y[] = {
            1.5198904114e-01, 5.0867040136e-02, 1.0000000000e+00, 1.4692167906e-01,
        5.2735698559e-02, 9.4988967227e-02, -3.7279857375e-03, -6.3117503437e-02,
        1.1951755284e-01, 4.0602835794e-02, -8.4609746761e-03, 9.6705987138e-04,
        -1.1429117964e-01, 5.0601587657e-03, 9.1936196974e-02, -1.1405201469e-01,
        -1.5222080912e-01, -7.3537170034e-02, 2.8327822502e-02, 1.1896074118e-01,
        -5.7487687365e-02  // Placeholder - will be computed separately
};

/**
 * Evaluate polynomial using optimized method
 *
 * For degree 5, we have {NUM_COEFFS} coefficients per direction.
 * Coefficients are ordered by total degree: (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ...
 */
float eval_polynomial(float coeffs[]; float x; float y)
{
    
    // Evaluate degree-5 polynomial using Horner's method
    // This is a placeholder - will be optimized per lens
    float eval_poly(float coeffs[]; float x; float y)
    {
        // TODO: Implement optimized evaluation
        return 0.0;
    }


    // Placeholder implementation
    // TODO: Generate optimized evaluation based on polynomial degree

    float result = 0.0;
    int idx = 0;
    int degree = 5;

    // Evaluate all terms: sum of c_ij * x^i * y^j
    for (int total_deg = 0; total_deg <= degree; total_deg++) {
        for (int i = 0; i <= total_deg; i++) {
            int j = total_deg - i;

            float x_pow = pow(x, i);
            float y_pow = pow(y, j);

            result += coeffs[idx] * x_pow * y_pow;
            idx++;
        }
    }

    return result;
}

/**
 * Sample aperture with depth of field
 *
 * Returns aperture sample position for given random values.
 * Supports circular and polygonal apertures.
 */
vector2 sample_aperture(float u; float v; int blades; float rotation)
{
    vector2 aperture_pos;

    if (blades == 0) {
        // Circular aperture - uniform disk sampling
        float r = sqrt(u);
        float theta = 2.0 * PI * v;
        aperture_pos = set(r * cos(theta), r * sin(theta));
    }
    else {
        // Polygonal aperture (N-sided regular polygon)
        // Map uniform square to N-gon
        float theta = 2.0 * PI * v + radians(rotation);
        float side_angle = 2.0 * PI / float(blades);

        // Distance from center to vertex
        float r = sqrt(u);

        // Map to polygon edge
        float angle_in_section = fmod(theta, side_angle);
        float section_center = side_angle * 0.5;

        // Approximate N-gon as circle scaled by cos(angle_to_edge)
        float edge_factor = cos(angle_in_section - section_center);
        r *= 1.0 / max(edge_factor, 0.001);

        aperture_pos = set(r * cos(theta), r * sin(theta));
    }

    return aperture_pos;
}

/**
 * Compute chromatic aberration offset
 *
 * Wavelength-dependent polynomial evaluation for RGB channels.
 * Default wavelengths: R=700nm, G=550nm, B=450nm
 */
vector chromatic_offset(vector2 sensor_pos; float wavelength)
{
    // Wavelength scaling factor (relative to 550nm green reference)
    float wl_scale = 550.0 / wavelength;

    // Chromatic aberration is typically < 1% effect
    float ca_strength = (wl_scale - 1.0) * 0.5;

    return set(ca_strength * sensor_pos.x, ca_strength * sensor_pos.y, 0.0);
}

/**
 * Main camera lens shader
 *
 * This is the entry point called by Karma for each camera ray.
 */
cvex karma_lentil_lens_test_double-gauss_50mm_f/2.0(
    // Standard camera shader interface
    export vector P = 0;           // Ray origin (world space)
    export vector I = {0, 0, -1};  // Ray direction (world space)

    // Camera parameters
    vector cam_pos = 0;             // Camera position
    matrix cam_xform = 1;           // Camera transform
    float focal_length = 50.0;  // Focal length (mm)
    float fstop = 2.0;      // F-stop number
    float focus_distance = 1000.0;  // Focus distance (mm)
    float sensor_width = 36.0;      // Sensor width (mm)

    // Sampling parameters
    float sx = 0.5;                 // Screen X (0-1)
    float sy = 0.5;                 // Screen Y (0-1)
    float lens_u = 0.5;             // Lens sample U (for DOF)
    float lens_v = 0.5;             // Lens sample V (for DOF)
    float time = 0.0;               // Time sample

    // Lens-specific parameters
    int bokeh_blades = 0;           // Aperture blades (0 = circular)
    float bokeh_rotation = 0.0;     // Aperture rotation (degrees)
    float chromatic_aberration = 1.0;  // Chromatic aberration strength
    float wavelength = 550.0;       // Wavelength (nm) - 550nm = green

    // Bidirectional filtering
    int enable_bidirectional = 1;   // Enable bidirectional filtering
    float bokeh_intensity = 1.0;    // Bokeh highlight multiplier
)
{
    // =========================================================================
    // 1. Sensor Position (Screen Space → Sensor Space)
    // =========================================================================

    // Convert screen coordinates to sensor coordinates (centered, in mm)
    float aspect_ratio = 1.5;  // TODO: Get from camera
    float sensor_height = sensor_width / aspect_ratio;

    vector2 sensor_pos = set(
        (sx - 0.5) * sensor_width,
        (sy - 0.5) * sensor_height
    );

    // =========================================================================
    // 2. Aperture Sampling (Depth of Field)
    // =========================================================================

    // Compute aperture diameter from f-stop
    // aperture_diameter = focal_length / fstop
    float aperture_radius = (focal_length / fstop) * 0.5;

    // Sample aperture position
    vector2 aperture_pos = sample_aperture(
        lens_u, lens_v,
        bokeh_blades,
        bokeh_rotation
    );

    aperture_pos *= aperture_radius;

    // =========================================================================
    // 3. Polynomial Lens Evaluation
    // =========================================================================

    // Normalize sensor position to [-1, 1] range for polynomial evaluation
    float sensor_norm_x = sensor_pos.x / (sensor_width * 0.5);
    float sensor_norm_y = sensor_pos.y / (sensor_height * 0.5);

    // Add aperture offset (normalized)
    float aperture_norm_x = aperture_pos.x / aperture_radius;
    float aperture_norm_y = aperture_pos.y / aperture_radius;

    // Evaluate exit pupil polynomial (sensor + aperture → lens exit)
    float exit_x = eval_polynomial(g_coeffs_exit_x,
                                   sensor_norm_x + aperture_norm_x * 0.1,
                                   sensor_norm_y + aperture_norm_y * 0.1);
    float exit_y = eval_polynomial(g_coeffs_exit_y,
                                   sensor_norm_x + aperture_norm_x * 0.1,
                                   sensor_norm_y + aperture_norm_y * 0.1);

    // =========================================================================
    // 4. Chromatic Aberration
    // =========================================================================

    vector ca_offset = chromatic_offset(sensor_pos, wavelength);
    exit_x += ca_offset.x * chromatic_aberration;
    exit_y += ca_offset.y * chromatic_aberration;

    // =========================================================================
    // 5. Ray Origin and Direction (Lens Space → World Space)
    // =========================================================================

    // Ray origin at sensor plane (lens space)
    vector ray_origin_lens = set(sensor_pos.x, sensor_pos.y, 0.0);

    // Ray direction through lens (lens space)
    // exit_x, exit_y are in normalized lens coordinates
    vector lens_exit_pos = set(exit_x, exit_y, focal_length);
    vector ray_dir_lens = normalize(lens_exit_pos - ray_origin_lens);

    // Transform to world space
    P = cam_pos + ray_origin_lens * cam_xform;
    I = normalize(ray_dir_lens * cam_xform);

    // =========================================================================
    // 6. Bidirectional Filtering (Optional)
    // =========================================================================

    if (enable_bidirectional) {
        // Bidirectional filtering adjusts ray weights for bokeh highlights
        // This is handled by the renderer's adaptive sampling
        // We just need to ensure rays are properly distributed

        // TODO: Implement bidirectional importance sampling
        // This may require additional AOV outputs
    }
}

/**
 * Shader Notes:
 *
 * 1. Polynomial Evaluation:
 *    - Coefficients are embedded at compile-time
 *    - Evaluation order can be optimized per lens
 *    - Horner's method or factored forms for performance
 *
 * 2. Chromatic Aberration:
 *    - Wavelength-dependent polynomial evaluation
 *    - Separate coefficients per wavelength possible
 *    - Current implementation uses simple scaling
 *
 * 3. Depth of Field:
 *    - Aperture sampling provides DOF effect
 *    - Focus distance handled by ray origin offset
 *    - Bokeh shape controlled by blades parameter
 *
 * 4. Performance:
 *    - Per-lens optimization possible
 *    - Polynomial degree affects evaluation cost
 *    - Typical cost: 50-200 instructions per ray
 *
 * 5. Future Enhancements:
 *    - Vignetting simulation (ray retry mechanism)
 *    - Lens housing geometry
 *    - Anamorphic projection (cylindrical coordinates)
 *    - Aspherical elements (modified polynomial terms)
 *    - Bokeh AOV outputs
 */
